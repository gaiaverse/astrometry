
// Code generated by stanc v2.26.1
#include <stan/model/model_header.hpp>
namespace magnitude_colour_position_sparse_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 29, column 4 to column 39)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 33, column 4 to column 21)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 36, column 15 to column 16)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 36, column 8 to column 20)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 37, column 15 to column 16)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 37, column 17 to column 18)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 37, column 8 to column 22)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 45, column 20 to column 258)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 44, column 30 to line 46, column 17)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 44, column 16 to line 46, column 17)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 50, column 20 to column 80)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 49, column 31 to line 51, column 17)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 49, column 16 to line 51, column 17)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 55, column 20 to column 77)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 54, column 30 to line 56, column 17)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 54, column 16 to line 56, column 17)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 41, column 26 to line 58, column 13)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 41, column 12 to line 58, column 13)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 40, column 22 to line 59, column 9)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 40, column 8 to line 59, column 9)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 35, column 4 to line 60, column 5)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 66, column 8 to column 39)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 65, column 18 to line 67, column 5)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 65, column 4 to line 67, column 5)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 72, column 12 to column 52)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 71, column 22 to line 73, column 9)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 71, column 8 to line 73, column 9)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 70, column 18 to line 74, column 5)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 70, column 4 to line 74, column 5)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 2, column 4 to column 19)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 3, column 4 to column 19)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 4, column 4 to column 28)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 5, column 4 to column 19)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 6, column 4 to column 28)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 7, column 4 to column 19)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 8, column 4 to column 19)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 9, column 4 to column 19)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 10, column 11 to column 12)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 10, column 13 to column 14)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 10, column 4 to column 23)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 11, column 11 to column 12)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 11, column 13 to column 14)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 11, column 4 to column 24)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 12, column 22 to column 23)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 12, column 4 to column 25)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 13, column 14 to column 15)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 13, column 4 to column 17)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 14, column 14 to column 15)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 14, column 4 to column 17)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 15, column 11 to column 12)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 15, column 4 to column 17)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 16, column 11 to column 12)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 16, column 4 to column 20)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 17, column 10 to column 11)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 17, column 12 to column 13)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 17, column 14 to column 15)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 17, column 4 to column 17)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 18, column 10 to column 11)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 18, column 12 to column 13)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 18, column 14 to column 15)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 18, column 4 to column 17)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 19, column 4 to column 21)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 20, column 15 to column 27)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 20, column 4 to column 42)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 21, column 21 to column 33)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 21, column 4 to column 35)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 22, column 21 to column 24)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 22, column 4 to column 26)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 23, column 4 to column 21)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 24, column 11 to column 23)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 24, column 4 to column 38)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 25, column 21 to column 33)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 25, column 4 to column 35)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 26, column 21 to column 24)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 26, column 4 to column 26)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 29, column 36 to column 37)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 29, column 11 to column 21)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 29, column 22 to column 32)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 33, column 16 to column 17)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 33, column 18 to column 19)",
                                                      " (in '/home/asfe2/Documents/Projects/EDR3_selection/astrometry/SelectionFunctionHammer/StanModels/magnitude_colour_position_sparse.stan', line 33, column 11 to column 12)"};



class magnitude_colour_position_sparse_model final : public model_base_crtp<magnitude_colour_position_sparse_model> {

 private:
  int P;
  int M;
  int M_subspace;
  int C;
  int C_subspace;
  int L;
  int H;
  int R;
  Eigen::Matrix<double, -1, -1> lambda;
  Eigen::Matrix<double, -1, -1> azimuth;
  std::vector<int> pixel_to_ring;
  std::vector<int> lower;
  std::vector<int> upper;
  Eigen::Matrix<double, -1, 1> mu;
  Eigen::Matrix<double, -1, 1> sigma;
  std::vector<std::vector<std::vector<int>>> k;
  std::vector<std::vector<std::vector<int>>> n;
  int cholesky_n_m;
  Eigen::Matrix<double, 1, -1> cholesky_w_m;
  std::vector<int> cholesky_v_m;
  std::vector<int> cholesky_u_m;
  int cholesky_n_c;
  Eigen::Matrix<double, -1, 1> cholesky_w_c;
  std::vector<int> cholesky_v_c;
  std::vector<int> cholesky_u_c;
 
 public:
  ~magnitude_colour_position_sparse_model() { }
  
  inline std::string model_name() const final { return "magnitude_colour_position_sparse_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.26.1", "stancflags = "};
  }
  
  
  magnitude_colour_position_sparse_model(stan::io::var_context& context__,
                                         unsigned int random_seed__ = 0,
                                         std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "magnitude_colour_position_sparse_model_namespace::magnitude_colour_position_sparse_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 30;
      context__.validate_dims("data initialization","P","int",
          context__.to_vec());
      P = std::numeric_limits<int>::min();
      
      current_statement__ = 30;
      P = context__.vals_i("P")[(1 - 1)];
      current_statement__ = 30;
      current_statement__ = 30;
      check_greater_or_equal(function__, "P", P, 0);
      current_statement__ = 31;
      context__.validate_dims("data initialization","M","int",
          context__.to_vec());
      M = std::numeric_limits<int>::min();
      
      current_statement__ = 31;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 31;
      current_statement__ = 31;
      check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 32;
      context__.validate_dims("data initialization","M_subspace","int",
          context__.to_vec());
      M_subspace = std::numeric_limits<int>::min();
      
      current_statement__ = 32;
      M_subspace = context__.vals_i("M_subspace")[(1 - 1)];
      current_statement__ = 32;
      current_statement__ = 32;
      check_greater_or_equal(function__, "M_subspace", M_subspace, 0);
      current_statement__ = 33;
      context__.validate_dims("data initialization","C","int",
          context__.to_vec());
      C = std::numeric_limits<int>::min();
      
      current_statement__ = 33;
      C = context__.vals_i("C")[(1 - 1)];
      current_statement__ = 33;
      current_statement__ = 33;
      check_greater_or_equal(function__, "C", C, 0);
      current_statement__ = 34;
      context__.validate_dims("data initialization","C_subspace","int",
          context__.to_vec());
      C_subspace = std::numeric_limits<int>::min();
      
      current_statement__ = 34;
      C_subspace = context__.vals_i("C_subspace")[(1 - 1)];
      current_statement__ = 34;
      current_statement__ = 34;
      check_greater_or_equal(function__, "C_subspace", C_subspace, 0);
      current_statement__ = 35;
      context__.validate_dims("data initialization","L","int",
          context__.to_vec());
      L = std::numeric_limits<int>::min();
      
      current_statement__ = 35;
      L = context__.vals_i("L")[(1 - 1)];
      current_statement__ = 35;
      current_statement__ = 35;
      check_greater_or_equal(function__, "L", L, 0);
      current_statement__ = 36;
      context__.validate_dims("data initialization","H","int",
          context__.to_vec());
      H = std::numeric_limits<int>::min();
      
      current_statement__ = 36;
      H = context__.vals_i("H")[(1 - 1)];
      current_statement__ = 36;
      current_statement__ = 36;
      check_greater_or_equal(function__, "H", H, 0);
      current_statement__ = 37;
      context__.validate_dims("data initialization","R","int",
          context__.to_vec());
      R = std::numeric_limits<int>::min();
      
      current_statement__ = 37;
      R = context__.vals_i("R")[(1 - 1)];
      current_statement__ = 37;
      current_statement__ = 37;
      check_greater_or_equal(function__, "R", R, 0);
      current_statement__ = 38;
      validate_non_negative_index("lambda", "R", R);
      current_statement__ = 39;
      validate_non_negative_index("lambda", "H", H);
      current_statement__ = 40;
      context__.validate_dims("data initialization","lambda","double",
          context__.to_vec(R, H));
      lambda = Eigen::Matrix<double, -1, -1>(R, H);
      stan::math::fill(lambda, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> lambda_flat__;
        current_statement__ = 40;
        assign(lambda_flat__, nil_index_list(), context__.vals_r("lambda"),
          "assigning variable lambda_flat__");
        current_statement__ = 40;
        pos__ = 1;
        current_statement__ = 40;
        for (int sym1__ = 1; sym1__ <= H; ++sym1__) {
          current_statement__ = 40;
          for (int sym2__ = 1; sym2__ <= R; ++sym2__) {
            current_statement__ = 40;
            assign(lambda,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              lambda_flat__[(pos__ - 1)], "assigning variable lambda");
            current_statement__ = 40;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 41;
      validate_non_negative_index("azimuth", "L", L);
      current_statement__ = 42;
      validate_non_negative_index("azimuth", "P", P);
      current_statement__ = 43;
      context__.validate_dims("data initialization","azimuth","double",
          context__.to_vec(L, P));
      azimuth = Eigen::Matrix<double, -1, -1>(L, P);
      stan::math::fill(azimuth, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> azimuth_flat__;
        current_statement__ = 43;
        assign(azimuth_flat__, nil_index_list(), context__.vals_r("azimuth"),
          "assigning variable azimuth_flat__");
        current_statement__ = 43;
        pos__ = 1;
        current_statement__ = 43;
        for (int sym1__ = 1; sym1__ <= P; ++sym1__) {
          current_statement__ = 43;
          for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
            current_statement__ = 43;
            assign(azimuth,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              azimuth_flat__[(pos__ - 1)], "assigning variable azimuth");
            current_statement__ = 43;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 44;
      validate_non_negative_index("pixel_to_ring", "P", P);
      current_statement__ = 45;
      context__.validate_dims("data initialization","pixel_to_ring","int",
          context__.to_vec(P));
      pixel_to_ring = std::vector<int>(P, std::numeric_limits<int>::min());
      
      current_statement__ = 45;
      assign(pixel_to_ring, nil_index_list(),
        context__.vals_i("pixel_to_ring"), "assigning variable pixel_to_ring");
      current_statement__ = 46;
      validate_non_negative_index("lower", "L", L);
      current_statement__ = 47;
      context__.validate_dims("data initialization","lower","int",
          context__.to_vec(L));
      lower = std::vector<int>(L, std::numeric_limits<int>::min());
      
      current_statement__ = 47;
      assign(lower, nil_index_list(), context__.vals_i("lower"),
        "assigning variable lower");
      current_statement__ = 48;
      validate_non_negative_index("upper", "L", L);
      current_statement__ = 49;
      context__.validate_dims("data initialization","upper","int",
          context__.to_vec(L));
      upper = std::vector<int>(L, std::numeric_limits<int>::min());
      
      current_statement__ = 49;
      assign(upper, nil_index_list(), context__.vals_i("upper"),
        "assigning variable upper");
      current_statement__ = 50;
      validate_non_negative_index("mu", "H", H);
      current_statement__ = 51;
      context__.validate_dims("data initialization","mu","double",
          context__.to_vec(H));
      mu = Eigen::Matrix<double, -1, 1>(H);
      stan::math::fill(mu, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> mu_flat__;
        current_statement__ = 51;
        assign(mu_flat__, nil_index_list(), context__.vals_r("mu"),
          "assigning variable mu_flat__");
        current_statement__ = 51;
        pos__ = 1;
        current_statement__ = 51;
        for (int sym1__ = 1; sym1__ <= H; ++sym1__) {
          current_statement__ = 51;
          assign(mu, cons_list(index_uni(sym1__), nil_index_list()),
            mu_flat__[(pos__ - 1)], "assigning variable mu");
          current_statement__ = 51;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 52;
      validate_non_negative_index("sigma", "H", H);
      current_statement__ = 53;
      context__.validate_dims("data initialization","sigma","double",
          context__.to_vec(H));
      sigma = Eigen::Matrix<double, -1, 1>(H);
      stan::math::fill(sigma, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> sigma_flat__;
        current_statement__ = 53;
        assign(sigma_flat__, nil_index_list(), context__.vals_r("sigma"),
          "assigning variable sigma_flat__");
        current_statement__ = 53;
        pos__ = 1;
        current_statement__ = 53;
        for (int sym1__ = 1; sym1__ <= H; ++sym1__) {
          current_statement__ = 53;
          assign(sigma, cons_list(index_uni(sym1__), nil_index_list()),
            sigma_flat__[(pos__ - 1)], "assigning variable sigma");
          current_statement__ = 53;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 54;
      validate_non_negative_index("k", "M", M);
      current_statement__ = 55;
      validate_non_negative_index("k", "C", C);
      current_statement__ = 56;
      validate_non_negative_index("k", "P", P);
      current_statement__ = 57;
      context__.validate_dims("data initialization","k","int",
          context__.to_vec(M, C, P));
      k = std::vector<std::vector<std::vector<int>>>(M, std::vector<std::vector<int>>(C, std::vector<int>(P, std::numeric_limits<int>::min())));
      
      {
        std::vector<int> k_flat__;
        current_statement__ = 57;
        assign(k_flat__, nil_index_list(), context__.vals_i("k"),
          "assigning variable k_flat__");
        current_statement__ = 57;
        pos__ = 1;
        current_statement__ = 57;
        for (int sym1__ = 1; sym1__ <= P; ++sym1__) {
          current_statement__ = 57;
          for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
            current_statement__ = 57;
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              current_statement__ = 57;
              assign(k,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                k_flat__[(pos__ - 1)], "assigning variable k");
              current_statement__ = 57;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 58;
      validate_non_negative_index("n", "M", M);
      current_statement__ = 59;
      validate_non_negative_index("n", "C", C);
      current_statement__ = 60;
      validate_non_negative_index("n", "P", P);
      current_statement__ = 61;
      context__.validate_dims("data initialization","n","int",
          context__.to_vec(M, C, P));
      n = std::vector<std::vector<std::vector<int>>>(M, std::vector<std::vector<int>>(C, std::vector<int>(P, std::numeric_limits<int>::min())));
      
      {
        std::vector<int> n_flat__;
        current_statement__ = 61;
        assign(n_flat__, nil_index_list(), context__.vals_i("n"),
          "assigning variable n_flat__");
        current_statement__ = 61;
        pos__ = 1;
        current_statement__ = 61;
        for (int sym1__ = 1; sym1__ <= P; ++sym1__) {
          current_statement__ = 61;
          for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
            current_statement__ = 61;
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              current_statement__ = 61;
              assign(n,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                n_flat__[(pos__ - 1)], "assigning variable n");
              current_statement__ = 61;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 62;
      context__.validate_dims("data initialization","cholesky_n_m","int",
          context__.to_vec());
      cholesky_n_m = std::numeric_limits<int>::min();
      
      current_statement__ = 62;
      cholesky_n_m = context__.vals_i("cholesky_n_m")[(1 - 1)];
      current_statement__ = 63;
      validate_non_negative_index("cholesky_w_m", "cholesky_n_m",
                                  cholesky_n_m);
      current_statement__ = 64;
      context__.validate_dims("data initialization","cholesky_w_m","double",
          context__.to_vec(cholesky_n_m));
      cholesky_w_m = Eigen::Matrix<double, 1, -1>(cholesky_n_m);
      stan::math::fill(cholesky_w_m, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> cholesky_w_m_flat__;
        current_statement__ = 64;
        assign(cholesky_w_m_flat__, nil_index_list(),
          context__.vals_r("cholesky_w_m"),
          "assigning variable cholesky_w_m_flat__");
        current_statement__ = 64;
        pos__ = 1;
        current_statement__ = 64;
        for (int sym1__ = 1; sym1__ <= cholesky_n_m; ++sym1__) {
          current_statement__ = 64;
          assign(cholesky_w_m,
            cons_list(index_uni(sym1__), nil_index_list()),
            cholesky_w_m_flat__[(pos__ - 1)],
            "assigning variable cholesky_w_m");
          current_statement__ = 64;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 65;
      validate_non_negative_index("cholesky_v_m", "cholesky_n_m",
                                  cholesky_n_m);
      current_statement__ = 66;
      context__.validate_dims("data initialization","cholesky_v_m","int",
          context__.to_vec(cholesky_n_m));
      cholesky_v_m = std::vector<int>(cholesky_n_m, std::numeric_limits<int>::min());
      
      current_statement__ = 66;
      assign(cholesky_v_m, nil_index_list(),
        context__.vals_i("cholesky_v_m"), "assigning variable cholesky_v_m");
      current_statement__ = 67;
      validate_non_negative_index("cholesky_u_m", "M + 1", (M + 1));
      current_statement__ = 68;
      context__.validate_dims("data initialization","cholesky_u_m","int",
          context__.to_vec((M + 1)));
      cholesky_u_m = std::vector<int>((M + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 68;
      assign(cholesky_u_m, nil_index_list(),
        context__.vals_i("cholesky_u_m"), "assigning variable cholesky_u_m");
      current_statement__ = 69;
      context__.validate_dims("data initialization","cholesky_n_c","int",
          context__.to_vec());
      cholesky_n_c = std::numeric_limits<int>::min();
      
      current_statement__ = 69;
      cholesky_n_c = context__.vals_i("cholesky_n_c")[(1 - 1)];
      current_statement__ = 70;
      validate_non_negative_index("cholesky_w_c", "cholesky_n_c",
                                  cholesky_n_c);
      current_statement__ = 71;
      context__.validate_dims("data initialization","cholesky_w_c","double",
          context__.to_vec(cholesky_n_c));
      cholesky_w_c = Eigen::Matrix<double, -1, 1>(cholesky_n_c);
      stan::math::fill(cholesky_w_c, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> cholesky_w_c_flat__;
        current_statement__ = 71;
        assign(cholesky_w_c_flat__, nil_index_list(),
          context__.vals_r("cholesky_w_c"),
          "assigning variable cholesky_w_c_flat__");
        current_statement__ = 71;
        pos__ = 1;
        current_statement__ = 71;
        for (int sym1__ = 1; sym1__ <= cholesky_n_c; ++sym1__) {
          current_statement__ = 71;
          assign(cholesky_w_c,
            cons_list(index_uni(sym1__), nil_index_list()),
            cholesky_w_c_flat__[(pos__ - 1)],
            "assigning variable cholesky_w_c");
          current_statement__ = 71;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 72;
      validate_non_negative_index("cholesky_v_c", "cholesky_n_c",
                                  cholesky_n_c);
      current_statement__ = 73;
      context__.validate_dims("data initialization","cholesky_v_c","int",
          context__.to_vec(cholesky_n_c));
      cholesky_v_c = std::vector<int>(cholesky_n_c, std::numeric_limits<int>::min());
      
      current_statement__ = 73;
      assign(cholesky_v_c, nil_index_list(),
        context__.vals_i("cholesky_v_c"), "assigning variable cholesky_v_c");
      current_statement__ = 74;
      validate_non_negative_index("cholesky_u_c", "C + 1", (C + 1));
      current_statement__ = 75;
      context__.validate_dims("data initialization","cholesky_u_c","int",
          context__.to_vec((C + 1)));
      cholesky_u_c = std::vector<int>((C + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 75;
      assign(cholesky_u_c, nil_index_list(),
        context__.vals_i("cholesky_u_c"), "assigning variable cholesky_u_c");
      current_statement__ = 76;
      validate_non_negative_index("z", "H", H);
      current_statement__ = 77;
      validate_non_negative_index("z", "M_subspace", M_subspace);
      current_statement__ = 78;
      validate_non_negative_index("z", "C_subspace", C_subspace);
      current_statement__ = 79;
      validate_non_negative_index("x", "M", M);
      current_statement__ = 80;
      validate_non_negative_index("x", "C", C);
      current_statement__ = 81;
      validate_non_negative_index("x", "P", P);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += H * M_subspace * C_subspace;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "magnitude_colour_position_sparse_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> z;
      z = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(H, Eigen::Matrix<local_scalar_t__, -1, -1>(M_subspace, C_subspace));
      stan::math::fill(z, DUMMY_VAR__);
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= H; ++sym1__) {
        current_statement__ = 1;
        assign(z, cons_list(index_uni(sym1__), nil_index_list()),
          in__.matrix(M_subspace, C_subspace), "assigning variable z");}
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> x;
      x = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(M, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(C, Eigen::Matrix<local_scalar_t__, -1, 1>(P)));
      stan::math::fill(x, DUMMY_VAR__);
      
      {
        current_statement__ = 3;
        validate_non_negative_index("a", "H", H);
        Eigen::Matrix<local_scalar_t__, -1, 1> a;
        a = Eigen::Matrix<local_scalar_t__, -1, 1>(H);
        stan::math::fill(a, DUMMY_VAR__);
        
        current_statement__ = 5;
        validate_non_negative_index("F", "R", R);
        current_statement__ = 6;
        validate_non_negative_index("F", "L", L);
        Eigen::Matrix<local_scalar_t__, -1, -1> F;
        F = Eigen::Matrix<local_scalar_t__, -1, -1>(R, L);
        stan::math::fill(F, DUMMY_VAR__);
        
        current_statement__ = 20;
        for (int m = 1; m <= M; ++m) {
          current_statement__ = 18;
          for (int c = 1; c <= C; ++c) {
            current_statement__ = 10;
            for (int h = 1; h <= H; ++h) {
              current_statement__ = 8;
              assign(a, cons_list(index_uni(h), nil_index_list()),
                (mu[(h - 1)] +
                  (sigma[(h - 1)] *
                    multiply(
                      multiply(
                        rvalue(cholesky_w_m,
                          cons_list(
                            index_min_max(cholesky_u_m[(m - 1)], (cholesky_u_m[
                                                                   ((m + 1) -
                                                                    1)] - 1)),
                            nil_index_list()), "cholesky_w_m"),
                        rvalue(z,
                          cons_list(index_uni(h),
                            cons_list(
                              index_multi(rvalue(cholesky_v_m,
                                            cons_list(
                                              index_min_max(cholesky_u_m[
                                              (m - 1)], (cholesky_u_m[
                                                          ((m + 1) - 1)] - 1)),
                                              nil_index_list()),
                                            "cholesky_v_m")),
                              cons_list(
                                index_multi(rvalue(cholesky_v_c,
                                              cons_list(
                                                index_min_max(cholesky_u_c[
                                                (c - 1)], (cholesky_u_c[
                                                            ((c + 1) - 1)] -
                                                            1)),
                                                nil_index_list()),
                                              "cholesky_v_c")),
                                nil_index_list()))), "z")),
                      rvalue(cholesky_w_c,
                        cons_list(
                          index_min_max(cholesky_u_c[(c - 1)], (cholesky_u_c[
                                                                 ((c + 1) -
                                                                   1)] - 1)),
                          nil_index_list()), "cholesky_w_c")))),
                "assigning variable a");}
            current_statement__ = 13;
            for (int l = 1; l <= L; ++l) {
              current_statement__ = 11;
              assign(F,
                cons_list(index_omni(),
                  cons_list(index_uni(l), nil_index_list())),
                multiply(
                  rvalue(lambda,
                    cons_list(index_omni(),
                      cons_list(
                        index_min_max(lower[(l - 1)], upper[(l - 1)]),
                        nil_index_list())), "lambda"),
                  rvalue(a,
                    cons_list(index_min_max(lower[(l - 1)], upper[(l - 1)]),
                      nil_index_list()), "a")), "assigning variable F");}
            current_statement__ = 16;
            for (int p = 1; p <= P; ++p) {
              current_statement__ = 14;
              assign(x,
                cons_list(index_uni(m),
                  cons_list(index_uni(c),
                    cons_list(index_uni(p), nil_index_list()))),
                dot_product(
                  rvalue(F,
                    cons_list(index_uni(pixel_to_ring[(p - 1)]),
                      nil_index_list()), "F"),
                  rvalue(azimuth,
                    cons_list(index_omni(),
                      cons_list(index_uni(p), nil_index_list())), "azimuth")),
                "assigning variable x");}}}
      }
      {
        current_statement__ = 24;
        for (int h = 1; h <= H; ++h) {
          current_statement__ = 22;
          lp_accum__.add(std_normal_lpdf<propto__>(to_vector(z[(h - 1)])));}
        current_statement__ = 29;
        for (int m = 1; m <= M; ++m) {
          current_statement__ = 27;
          for (int c = 1; c <= C; ++c) {
            current_statement__ = 25;
            lp_accum__.add(
              binomial_logit_lpmf<propto__>(k[(m - 1)][(c - 1)],
                n[(m - 1)][(c - 1)], x[(m - 1)][(c - 1)]));}}
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "magnitude_colour_position_sparse_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      std::vector<Eigen::Matrix<double, -1, -1>> z;
      z = std::vector<Eigen::Matrix<double, -1, -1>>(H, Eigen::Matrix<double, -1, -1>(M_subspace, C_subspace));
      stan::math::fill(z, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= H; ++sym1__) {
        current_statement__ = 1;
        assign(z, cons_list(index_uni(sym1__), nil_index_list()),
          in__.matrix(M_subspace, C_subspace), "assigning variable z");}
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> x;
      x = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(C, Eigen::Matrix<double, -1, 1>(P)));
      stan::math::fill(x, std::numeric_limits<double>::quiet_NaN());
      
      for (int sym1__ = 1; sym1__ <= C_subspace; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M_subspace; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= H; ++sym3__) {
            vars__.emplace_back(
              rvalue(z,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))), "z"));}
        }}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      {
        current_statement__ = 3;
        validate_non_negative_index("a", "H", H);
        Eigen::Matrix<double, -1, 1> a;
        a = Eigen::Matrix<double, -1, 1>(H);
        stan::math::fill(a, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 5;
        validate_non_negative_index("F", "R", R);
        current_statement__ = 6;
        validate_non_negative_index("F", "L", L);
        Eigen::Matrix<double, -1, -1> F;
        F = Eigen::Matrix<double, -1, -1>(R, L);
        stan::math::fill(F, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 20;
        for (int m = 1; m <= M; ++m) {
          current_statement__ = 18;
          for (int c = 1; c <= C; ++c) {
            current_statement__ = 10;
            for (int h = 1; h <= H; ++h) {
              current_statement__ = 8;
              assign(a, cons_list(index_uni(h), nil_index_list()),
                (mu[(h - 1)] +
                  (sigma[(h - 1)] *
                    multiply(
                      multiply(
                        rvalue(cholesky_w_m,
                          cons_list(
                            index_min_max(cholesky_u_m[(m - 1)], (cholesky_u_m[
                                                                   ((m + 1) -
                                                                    1)] - 1)),
                            nil_index_list()), "cholesky_w_m"),
                        rvalue(z,
                          cons_list(index_uni(h),
                            cons_list(
                              index_multi(rvalue(cholesky_v_m,
                                            cons_list(
                                              index_min_max(cholesky_u_m[
                                              (m - 1)], (cholesky_u_m[
                                                          ((m + 1) - 1)] - 1)),
                                              nil_index_list()),
                                            "cholesky_v_m")),
                              cons_list(
                                index_multi(rvalue(cholesky_v_c,
                                              cons_list(
                                                index_min_max(cholesky_u_c[
                                                (c - 1)], (cholesky_u_c[
                                                            ((c + 1) - 1)] -
                                                            1)),
                                                nil_index_list()),
                                              "cholesky_v_c")),
                                nil_index_list()))), "z")),
                      rvalue(cholesky_w_c,
                        cons_list(
                          index_min_max(cholesky_u_c[(c - 1)], (cholesky_u_c[
                                                                 ((c + 1) -
                                                                   1)] - 1)),
                          nil_index_list()), "cholesky_w_c")))),
                "assigning variable a");}
            current_statement__ = 13;
            for (int l = 1; l <= L; ++l) {
              current_statement__ = 11;
              assign(F,
                cons_list(index_omni(),
                  cons_list(index_uni(l), nil_index_list())),
                multiply(
                  rvalue(lambda,
                    cons_list(index_omni(),
                      cons_list(
                        index_min_max(lower[(l - 1)], upper[(l - 1)]),
                        nil_index_list())), "lambda"),
                  rvalue(a,
                    cons_list(index_min_max(lower[(l - 1)], upper[(l - 1)]),
                      nil_index_list()), "a")), "assigning variable F");}
            current_statement__ = 16;
            for (int p = 1; p <= P; ++p) {
              current_statement__ = 14;
              assign(x,
                cons_list(index_uni(m),
                  cons_list(index_uni(c),
                    cons_list(index_uni(p), nil_index_list()))),
                dot_product(
                  rvalue(F,
                    cons_list(index_uni(pixel_to_ring[(p - 1)]),
                      nil_index_list()), "F"),
                  rvalue(azimuth,
                    cons_list(index_omni(),
                      cons_list(index_uni(p), nil_index_list())), "azimuth")),
                "assigning variable x");}}}
      }
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= P; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              vars__.emplace_back(
                x[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      std::vector<Eigen::Matrix<double, -1, -1>> z;
      z = std::vector<Eigen::Matrix<double, -1, -1>>(H, Eigen::Matrix<double, -1, -1>(M_subspace, C_subspace));
      stan::math::fill(z, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> z_flat__;
        current_statement__ = 1;
        assign(z_flat__, nil_index_list(), context__.vals_r("z"),
          "assigning variable z_flat__");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= C_subspace; ++sym1__) {
          current_statement__ = 1;
          for (int sym2__ = 1; sym2__ <= M_subspace; ++sym2__) {
            current_statement__ = 1;
            for (int sym3__ = 1; sym3__ <= H; ++sym3__) {
              current_statement__ = 1;
              assign(z,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                z_flat__[(pos__ - 1)], "assigning variable z");
              current_statement__ = 1;
              pos__ = (pos__ + 1);}}}
      }
      for (int sym1__ = 1; sym1__ <= H; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= C_subspace; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= M_subspace; ++sym3__) {
            vars__.emplace_back(
              rvalue(z,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym3__),
                    cons_list(index_uni(sym2__), nil_index_list()))), "z"));}
        }}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("z");
    names__.emplace_back("x");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(H),
                                             static_cast<size_t>(M_subspace),
                                             static_cast<size_t>(C_subspace)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(C),
                                             static_cast<size_t>(P)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= C_subspace; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= M_subspace; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= H; ++sym3__) {
              {
                param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= P; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= C_subspace; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= M_subspace; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= H; ++sym3__) {
              {
                param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= P; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << H << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << M_subspace << ",\"cols\":" << C_subspace << "}},\"block\":\"parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << C << ",\"element_type\":{\"name\":\"vector\",\"length\":" << P << "}}},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << H << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << M_subspace << ",\"cols\":" << C_subspace << "}},\"block\":\"parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << C << ",\"element_type\":{\"name\":\"vector\",\"length\":" << P << "}}},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}

using stan_model = magnitude_colour_position_sparse_model_namespace::magnitude_colour_position_sparse_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return magnitude_colour_position_sparse_model_namespace::profiles__;
}

#endif


